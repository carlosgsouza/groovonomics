<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html xml:lang="pt" > 
<head><title>Como programadores usam sistemas de tipos estticos e dinmicos em Groovy</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html --> 
<meta name="src" content="sbc-template.tex"> 
<meta name="date" content="2013-06-15 15:55:00"> 
<link rel="stylesheet" type="text/css" href="sbc-template.css"> 
</head><body 
>
       <div class="maketitle">



<h2 class="titleHead">Como programadores usam sistemas de tipos estáticos e
dinâmicos em Groovy</h2>
<div class="author" ><span 
class="ptmb7t-x-x-120">Carlos Souza</span></div>
<br />
<span 
class="cmr-8">1</span>Departamento de Ciência da Computação
<br />  Universidade Federal de Minas Gerais<br /><br /><br />
<br />       <span 
class="pcrr7t-">carlosgsouza@gmail.com</span>
<br />
       </div><div 
class="abstract" 
>
    <span 
class="ptmbi7t-x-x-120">Abstract.</span>  <span 
class="ptmri7t-x-x-120">Embora linguagens de programa</span><span 
class="ptmri7t-x-x-120">ç</span><span 
class="ptmri7t-x-x-120">ão din</span><span 
class="ptmri7t-x-x-120">âmicas estejam recebendo</span>
    <span 
class="ptmri7t-x-x-120">cada   vez   mais   aten</span><span 
class="ptmri7t-x-x-120">ç</span><span 
class="ptmri7t-x-x-120">ão   da   ind</span><span 
class="ptmri7t-x-x-120">ústria   nos   </span><span 
class="ptmri7t-x-x-120">últimos   anos,   pouco   tem   se</span>
    <span 
class="ptmri7t-x-x-120">estudado sobre a influ</span><span 
class="ptmri7t-x-x-120">ência dessas linguagens no desenvolvimento de sistemas,</span>
    <span 
class="ptmri7t-x-x-120">principalmente  do  ponto  de  vista  da  engenharia  de  software.  Este  trabalho</span>
    <span 
class="ptmri7t-x-x-120">é  o  primeiro  passo  de  um  estudo  cujo  objetivo  </span><span 
class="ptmri7t-x-x-120">é  entender  como  recursos  de</span>
    <span 
class="ptmri7t-x-x-120">linguagens din</span><span 
class="ptmri7t-x-x-120">âmicas, em particular sistemas de tipos din</span><span 
class="ptmri7t-x-x-120">âmicos, influenciam a</span>
    <span 
class="ptmri7t-x-x-120">evolu</span><span 
class="ptmri7t-x-x-120">ç</span><span 
class="ptmri7t-x-x-120">ão de tais sistemas de software. Neste trabalho </span><span 
class="ptmri7t-x-x-120">é apresentada uma an</span><span 
class="ptmri7t-x-x-120">álise</span>
    <span 
class="ptmri7t-x-x-120">com mais de 1000 projetos a respeito de como programadores usam sistemas de</span>
    <span 
class="ptmri7t-x-x-120">tipos em Groovy, uma linguagem onde o programador pode escolher, para cada</span>
    <span 
class="ptmri7t-x-x-120">declara</span><span 
class="ptmri7t-x-x-120">ç</span><span 
class="ptmri7t-x-x-120">ão, tipagem est</span><span 
class="ptmri7t-x-x-120">ática ou din</span><span 
class="ptmri7t-x-x-120">âmica. Tal an</span><span 
class="ptmri7t-x-x-120">álise evidencia, do ponto de</span>
    <span 
class="ptmri7t-x-x-120">vista dos programadores, quais fatores mais influenciam a escolha de sistema de</span>
    <span 
class="ptmri7t-x-x-120">tipos. Resultados mostram que, quando podem escolher, programadores Groovy</span>
    <span 
class="ptmri7t-x-x-120">preferem  tipagem  est</span><span 
class="ptmri7t-x-x-120">ática  na  maioria  dos  casos.  Esta  escolha  </span><span 
class="ptmri7t-x-x-120">é  ainda  mais</span>
    <span 
class="ptmri7t-x-x-120">frequente  em  projetos  maiores,  onde  manuten</span><span 
class="ptmri7t-x-x-120">ç</span><span 
class="ptmri7t-x-x-120">ão  de  software  </span><span 
class="ptmri7t-x-x-120">é  uma  quest</span><span 
class="ptmri7t-x-x-120">ão</span>
    <span 
class="ptmri7t-x-x-120">mais importante.</span>
</div>
<a 
 id="x1-2r1"></a>
<h3 class="sectionHead"><span class="titlemark">1.  </span> <a 
 id="x1-10001"></a>Introdução</h3>
<!--l. 70--><p class="noindent" >Linguagens de programação com tipagem dinâmica tem se tornado cada vez mais populares na
indústristra de software nos últimos anos. De acordo com o TIOBE Programming Community
Index<span class="footnote-mark"><a 
href="sbc-template2.html#fn1x0"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-1001f1"></a>,
um conhecido ranking que mede a popularidade de linguagens de programação, 27% das
linguagens de programação adotadas na indústria possuem tipagem dinâmica. Em
2001, esse número era de apenas 17%. Entre as 10 linguagens no topo do ranking, 4
possuem sistemas de tipos dinâmicos: Ruby, Perl, Python e PHP. Em 1997, dentre
essas linguagens, apenas Python e Perl apareciam no ranking, em 29<span 
class="ptmr8c-x-x-120">º </span>e 7<span 
class="ptmr8c-x-x-120">º </span>lugares
respectivamente.

<!--l. 81--><p class="indent" >       Linguagens com tipagem dinâmica possuem algumas vantagens sobre aquelas com
tipagem estática. Por serem mais simples, os programadores conseguem executar suas tarefas de
desenvolvimento mais rapidamente. Ainda, ao removerem o trabalho burocrático e repetitivo de
declarar os tipos das variáveis, estas linguagens permitem que seus usuários foquem no
problema a ser resolvido, ao invés de se preocuparem com as regras da linguagem <span class="cite">[<a 
href="#Xjit">Chang et&#x00A0;al.
2011</a>,&#x00A0;<a 
href="#Xdynamically_typed_languages">Tratt 2009</a>]</span>.
<!--l. 89--><p class="indent" >       Por outro lado, sistemas de tipos estáticos, também possuem suas vantagens. Estes
conseguem prevenir erros de tipo em tempo de compilação. Pode-se argumentar que
declarações de tipos aumentam a manutenibilidade de sistemas pois estas atuam como
documentação, informando ao programador sobre a natureza de cada variável. Alem disso,
sistemas escritos a partir desse destas linguagens tendem a ser mais eficientes, uma vez que não
precisam realizar checagem de tipo durante a execução<span class="cite">[<a 
href="#Xtype_systems">Cardelli 1996</a>,&#x00A0;<a 
href="#Xtypes_and_programming_languages">Pierce 2002</a>,&#x00A0;<a 
href="#Xbruce2002foundations">Bruce
2002</a>]</span> .
<!--l. 98--><p class="indent" >       Embora muito tenha se discutido a respeito das vantagens e desvantagens de sistemas de
tipos estáticos ou dinâmicos, há poucas evidências a respeito da real influência destes sobre a
evolução de sistemas de software. Alguns trabalhos <span class="cite">[<a 
href="#Xexperiment_with_purity">Hanenberg 2010</a>,&#x00A0;<a 
href="#Xtype_sytems_in_parameters">Prechelt and Tichy
1998</a>,&#x00A0;<a 
href="#Xruby_vs_druby">Daly et&#x00A0;al. 2009</a>]</span> chegam a tentar analisar essa questão através de estudos controlados,
mas esses não são capazes de reproduzir com precisão o contexto da indústria de software e
portanto não são muito confiáveis.
<!--l. 106--><p class="indent" >       Este artigo apresenta uma análise de como programadores usam sistemas de tipo em
Groovy, uma linguagem com sistemas híbrido. Em Groovy, um programador pode escolher,
para cada declaração, se utilizará tipagem dinâmica ou estática. Assim, espera-se que
programadores escolham para cada situação o sistema de tipos mais adequado. Ao analisar
como estes programadores usam sistemas de tipo, é possível entender quais fatores influenciam
nessa decisão. Essa informação é capaz de ajudar desenvolvedores na escolha de linguagens de
programação de acordo com o contexto em que se encontram. Projetistas de linguagens tambem
podem se beneficiar desse conhecimento ao entenderem melhor como sistemas de tipos são
usados.
<a 
 id="x1-1002r1"></a>
<h4 class="subsectionHead"><span class="titlemark">1.1.  </span> <a 
 id="x1-20001"></a>Groovy</h4>
<!--l. 121--><p class="noindent" >Groovy é uma linguagem dinâmica projetada para ser executada sobre a Java Virtual Machine.
Sua sintaxe é parecida com a de Java, porem possui ela inclui funciondalidades dinânmicas,
como metaprogramação e closures. É possível ainda escrever scripts em Groovy. Atualmente,
Groovy ocupa a 50<sup class="textsuperscript"><span 
class="ptmr7t-x-x-109">a</span></sup> colocação no TIOBE Programming Community Index. Sua popularidade
tem crescido bastante nos últimos anos, principalmente entre programadores Java que desejam
incorporar algumas das facilidades de linguagens dinâmicas sem terem que aprender
uma linguagem completamente nova ou mudar a plataforma de execução de seus
sistemas.
<!--l. 132--><p class="indent" >       Em Groovy, um programador pode escolher tipar suas declarações ou não. Tipagem
estática e dinâmica podem ser combinadas no mesmo código livremente. É possível, por
exemplo, definir o tipo de retorno de um método, mas manter os parâmetros deste método
dinamicamente tipados. Graças à essa propriedade, é possível realizar uma análise sobre a
preferência dos desenvolvedores com relação ao sistema de tipos para cada situação. O
algoritmo <a 
href="#x1-2008r1">1<!--tex4ht:ref: codigoGroovy --></a> mostra um trecho de código escrito em Groovy.


<!--l. 142--><p class="indent" >       <a 
 id="x1-2008r1"></a><hr class="float"><div class="float" 
>

<!--l. 142-->
<div class="lstlisting" id="listing-1"><span class="label"><a 
 id="x1-2001r1"></a></span>ClassData&#x00A0;agregateClasses(classFilter)&#x00A0;<span 
class="cmsy-10x-x-120">{</span>&#x00A0;<br /><span class="label"><a 
 id="x1-2002r2"></a></span>&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;def&#x00A0;result&#x00A0;=&#x00A0;new&#x00A0;ClassData()&#x00A0;<br /><span class="label"><a 
 id="x1-2003r3"></a></span>&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;classes.findAll(classFilter).each&#x00A0;<span 
class="cmsy-10x-x-120">{</span>&#x00A0;<br /><span class="label"><a 
 id="x1-2004r4"></a></span>&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;result&#x00A0;+=&#x00A0;it&#x00A0;<br /><span class="label"><a 
 id="x1-2005r5"></a></span>&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;<span 
class="cmsy-10x-x-120">}</span>&#x00A0;<br /><span class="label"><a 
 id="x1-2006r6"></a></span>&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;result&#x00A0;<br /><span class="label"><a 
 id="x1-2007r7"></a></span><span 
class="cmsy-10x-x-120">}</span>
</div>
<br /> <div class="caption" 
><span class="id">Algorithm  1:  </span><span  
class="content">Um  exemplo  de  código  escrito  em  Groovy.  O  método  agregateClasses
possui seu tipo de retorno, ClassData, declarado estaticamente. O parâmetro classFielter e
a variável local result porem não possuem declaração de tipo. Ainda é possível observar
o uso de um closure, outra característica dinâmica da linguagem, sendo passado como
parâmetro para o método findAll.</span></div><!--tex4ht:label?: x1-2008r1 -->

       </div><hr class="endfloat" />
<a 
 id="x1-2009r1"></a>
<h3 class="sectionHead"><span class="titlemark">2.  </span> <a 
 id="x1-30002"></a>Trabalhos Relacionados</h3>
<!--l. 168--><p class="noindent" >Há vários trabalhos na literatura que comparam sistemas de tipos estáticos e dinâmicos, porem,
estes trabalhos pouco avaliam como sistemas de tipos podem influenciar na evolução de
software. A maioria deles compara a produtividade em estudos controlados de curta
duração, com pouco ou nenhum trabalho em equipe usando alunos como exemplos
de desenvolvedores. Esses estudos porem não são capazes de representar bem as
situações encontradas por desenvolvedores no cotidiano da indústria de software,
onde eles tem que manter seus sistemas de software por vários anos e trabalhar em
grupo.
<!--l. 178--><p class="indent" >       Em <span class="cite">[<a 
href="#Xexperiment_with_purity">Hanenberg 2010</a>]</span>, o autor compara o desempenho de dois grupos de alunos ao
desenvolverem dois sistemas de software pequenos. Um grupo utilizou uma linguagem
estaticamente tipada enquanto o outro usou uma linguagem dinamicamente tipada. As
linguagens usadas foram duas versões de uma linguagem criada pelo autor, Purity. A única
diferença entre as duas versões era o sistema de tipos usado, assim foi possível eliminar
quaisquer outras diferenças que pudessem influenciar o resultado. Os resultados mostram que o
grupo que trabalhou com a versão de Purity com tipagem dinâmica foi razoavelmente mais
produt
<!--l. 188--><p class="indent" >       Em uma continuação do estudo anterior <span class="cite">[<a 
href="#Xhanenberg_icpc">Kleinschmager et&#x00A0;al. 2012</a>]</span>, os autores
chegaram a conclusões opostas. Eles compararam o desempenho de dois grupos em tarefas de
manutenção, um utilizando Java e outro utilizando Groovy para simular um Java dinamicamente
tipado. Neste caso, o grupo utilizando Java foi muito mais produtivo. Há ainda outros estudos do
mesmo grupo, que tendem a suportar a hipótese de que linguagens com tipagem estática
possuem maior produtividade .
<!--l. 196--><p class="indent" >       Resultados semelhantes ao do estudo anterior foram obtidos em alguns estudo bastante
antigos <span class="cite">[<a 
href="#Xtype_sytems_in_parameters">Prechelt and Tichy 1998</a>,&#x00A0;<a 
href="#XGannon:1977:EED:359763.359800">Gannon 1977</a>]</span>. Estes estudos porem, por ser muito antigo,
não representa bem o contexto atual, onde práticas, como testes automatizados, são mais
populares e, em geral, ajudam a prevenir alguns dos erros comuns em sistemas dinamicamente
tipados.
<!--l. 203--><p class="indent" >       Já nos experimentos realizados em <span class="cite">[<a 
href="#Xruby_vs_druby">Daly et&#x00A0;al. 2009</a>]</span>, os autores não conseguiram
perceber nenhum ganho de produtividade ou qualidade quando tipagem estática é utilizada. Eles
compararam o comportamento de desenvolvedores ao trabalharem com duas linguagens, Ruby e
Diammondback Ruby (DRuby), uma versão estaticamente tipada de Ruby. Esse estudo mostrou
que o compilador de DRuby raramente aponta erros que já não eram evidentes para os
programadores. Aparentemente, programadores se adaptam à falta de informações sobre
tipos.
<!--l. 212--><p class="indent" >       Em <span class="cite">[<a 
href="#Xeval_js">Richards et&#x00A0;al. 2011</a>]</span>, é estudado o impacto do uso da função <span 
class="cmsy-10x-x-120">\</span>emph<span 
class="cmsy-10x-x-120">{</span>eval<span 
class="cmsy-10x-x-120">} </span>em
Javascript sobre a robustez de páginas web. Esta função é capaz de executar código a partir de
texto, modificando dinamicamente o comportamento do programa. Embora poderosa, essa
funcionalidade prejudica a legibilidade do código. Os autores automatizaram um browser que
interagiu com mais de 10.000 páginas coletando o log de execução do código Javascript dessas
páginas. Ao final os autores conseguem mostrar como essas páginas utilizam o eval e quais são
os erros mais comuns.

<a 
 id="x1-3001r4"></a>
<h3 class="sectionHead"><span class="titlemark">3.  </span> <a 
 id="x1-40003"></a>Configuração do Estudo</h3>
<!--l. 224--><p class="noindent" >O estudo apresentado neste trabalho consite em analisar o uso de sistemas de tipos estático e
dinâmico em um conjunto de projetos escritos utilizando a linguagem Groovy. A escolha por um
destes sistemas é relacionada com fatores como o tamanho do projeto, tipo de declaração,
visibilidade da declaração, entre outros. O objetivo é descobrir quais fatores os desenvolvedores
consideram importantes na hora de escolher um sistema de tipos. Este estudo baseia-se na
hipótese de que, dado que um programador é livre para escolher o sistema de tipos para
cada declaração individualmente, ele irá sempre escolher o melhor sistema de tipos
para cada situação encontrada. A seção <a 
href="#x1-130005">5<!--tex4ht:ref: sec:ameaca --></a> discute algumas ameaças à validade desta
hipótese.
<a 
 id="x1-4001r2"></a>
<h4 class="subsectionHead"><span class="titlemark">3.1.  </span> <a 
 id="x1-50001"></a>Dataset</h4>
<!--l. 239--><p class="noindent" >Os projetos utilizados neste estudo foram obtidos do GitHub, um serviço de controle de versão
baseado em Git bastante popular entre programadores Groovy. É possível obter do
GitHub, de forma automatizada, o código de todas as versões dos sistemas sob estudo,
assim como o histórico de commits e informações a respeito de cada desenvolvedor
envolvido. Esta massa de dados é bastante significativa. São, ao todo, 1112 projetos
abertos, totalizando 1676KLOC, considerando apenas a última versão de cada sistema.
Estes sistemas foram desenvolvidos por 926 programadores e a idade de todos os
projetos somada é de quase 300 anos. A figura <a 
href="#x1-5001r1">1<!--tex4ht:ref: fig:size_distribution --></a> mostra a distribuição do tamanho dos
projetos.
<!--l. 251--><p class="indent" >       <hr class="figure"><div class="figure" 
>

<a 
 id="x1-5001r1"></a>


<!--l. 252--><p class="noindent" ><img 
src="0_Users_carlosgsouza_Dropbox_UFMG_Mestrado_mes_artigo_size_distribution.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figura&#x00A0;1: </span><span  
class="content">Distribuição dos 1112 projetos utilizados por tamanho do projeto em LOC.</span></div><!--tex4ht:label?: x1-5001r1 -->

<!--l. 258--><p class="indent" >       </div><hr class="endfigure">
<a 
 id="x1-5002r6"></a>
<h4 class="subsectionHead"><span class="titlemark">3.2.  </span> <a 
 id="x1-60002"></a>Analisador Estático de Código</h4>
<!--l. 264--><p class="noindent" >Para obter os sistemas de tipos utilizados em cada declaração foi implementado
um analisador estático de código baseado na API de manipulação de
ASTs<span class="footnote-mark"><a 
href="sbc-template3.html#fn2x0"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-6001f2"></a>
de Groovy. Esta API permite ao programador modificar em tempo de compilação o código
gerado pelo programa. Em outras palavras, é possível programar o compilador. É possível ainda
navegar pela AST gerada para cada uma das fases do compilador para um módulo Groovy. A
fase escolhida para recolher informações sobre os sistemas de tipos utilizados foi a de
Conversão. Nesta fase, já é possível acessar todas as declarações escritas pelo programador,
porem o compilador ainda não tentou resolver referências a outros tipos. Sendo assim, o
analisador estático consegue analisar cada arquivo separadamente, sem precisar resolver
nenhuma dependência externa.
<!--l. 280--><p class="indent" >       Para cada classe ou script escrito em Groovy, são obtidas informações dos seguintes
tipos de declarações
       <ul class="itemize1">
       <li class="itemize">Retorno de Método
       </li>
       <li class="itemize">Parâmetro de Método
       </li>
       <li class="itemize">Parâmetro de Construtor
       </li>
       <li class="itemize">Campo
       </li>
       <li class="itemize">Variável Local</li></ul>
<!--l. 289--><p class="noindent" >Cada um dos tipos de declaração acima é agrupado por visibilidade, pública, privada ou protegida. É
guardado ainda, para cada classe, se esta classe é um script ou a implementação de um teste
automatizado.
<a 
 id="x1-6002r5"></a>
<h3 class="sectionHead"><span class="titlemark">4.  </span> <a 
 id="x1-70004"></a>Resultados</h3>
<a 
 id="x1-7001r8"></a>
<h4 class="subsectionHead"><span class="titlemark">4.1.  </span> <a 
 id="x1-80001"></a>Resultado Geral</h4>
<!--l. 299--><p class="noindent" >A tabela <a 
href="#x1-8001r1">1<!--tex4ht:ref: tab:geral --></a> mostra o valor relativo do uso dos sistemas de tipos considerando todas as
declarações. Esta tabela mostra que, no geral, programadores preferm utilizar tipagem
estática.
       <div class="table">

<!--l. 304--><p class="indent" >       <a 
 id="x1-8001r1"></a><hr class="float"><div class="float" 
>

 <div class="caption" 
><span class="id">Tabela&#x00A0;1: </span><span  
class="content">Declarações em Groovy</span></div><!--tex4ht:label?: x1-8001r1 -->
<div class="tabular"> <table id="TBL-3" class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
><colgroup id="TBL-3-1g"><col 
id="TBL-3-1"></colgroup><colgroup id="TBL-3-2g"><col 
id="TBL-3-2"></colgroup><colgroup id="TBL-3-3g"><col 
id="TBL-3-3"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-1-"><td  style="white-space:nowrap; text-align:center;" id="TBL-3-1-1"  
class="td11">   </td><td  style="white-space:nowrap; text-align:center;" id="TBL-3-1-2"  
class="td11">Tipagem Estática</td><td  style="white-space:nowrap; text-align:center;" id="TBL-3-1-3"  
class="td11">Tipagem Dinâmica</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-2-"><td  style="white-space:nowrap; text-align:center;" id="TBL-3-2-1"  
class="td11">Geral</td><td  style="white-space:nowrap; text-align:center;" id="TBL-3-2-2"  
class="td11">    60%          </td><td  style="white-space:nowrap; text-align:center;" id="TBL-3-2-3"  
class="td11">     40%            </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-3-"><td  style="white-space:nowrap; text-align:center;" id="TBL-3-3-1"  
class="td11">    </td></tr></table>
</div>

       </div><hr class="endfloat" />
       </div>
<a 
 id="x1-8002r10"></a>
<h4 class="subsectionHead"><span class="titlemark">4.2.  </span> <a 
 id="x1-90002"></a>Resultados por Tipo de Declaralção</h4>
<!--l. 328--><p class="noindent" >A figura <a 
href="#x1-9001r2">2<!--tex4ht:ref: fig:tipo_declaracao --></a> mostra a quantidade relativa de declarações agrupadas por tipo de declaração.
Variáveis locais utilizam tipagem dinâmica com mais frequência que outros tipos de
declarações. Esse resultado já era esperado já que este tipo de variável possui menor escopo e
ciclo de vida. Programadores não precisam se preocupar tanto em tipar essas variáveis já que
elas não afetam outras partes do programa. Alem disso, por serem criadas localmente, o tipo
destas variáveis pode ser facilmente inferido por programadores que venham a trabalhar com
essas variáveis.
<!--l. 338--><p class="indent" >       Os tipos de declaração mais estaticamente tipados são os parâmetros de construtores.
Pode se argumentar que há uma preocupação maior dos desenvolvedores em definir a interface
dos métodos construtores uma vez que estes métodos definem a própria criação de um objeto e,
caso não sejam invocados corretamente, podem comprometer o funcionamento desta
instância. Outra possível explicação é que, como construtores tem o tipo de retorno
tipado estaticamente por definição, programadores acabem tipando os parâmetros por
coerência.
<!--l. 347--><p class="indent" >       <hr class="figure"><div class="figure" 
>

<a 
 id="x1-9001r2"></a>


<!--l. 348--><p class="noindent" ><img 
src="1_Users_carlosgsouza_Dropbox_UFMG_Mestrado_mes_artigo_tipo.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figura&#x00A0;2: </span><span  
class="content">Sistemas de Tipo por Tipo de Declaração.</span></div><!--tex4ht:label?: x1-9001r2 -->

<!--l. 353--><p class="indent" >       </div><hr class="endfigure">
<a 
 id="x1-9002r12"></a>
<h4 class="subsectionHead"><span class="titlemark">4.3.  </span> <a 
 id="x1-100003"></a>Resultados por Visibilidade</h4>
<!--l. 359--><p class="noindent" >O gráfico da figura <a 
href="#x1-10001r3">3<!--tex4ht:ref: fig:visibilidade --></a> mostra o uso de sistema de tipos por visibilidade de cada declaração.
Repare que declarações públicas são estaticamente tipadas com mais frequência. Isto demonstra
uma maior preocupação de desenvolvedores em tipar métodos e campos que compões a
interface de um módulo. Outro resultado interessante é que métodos protegidos são tipados com
muita frequência. Em geral, métodos protegidos são utilizados como uma maneira de delegar
parte da implementação necessária a uma super classe para a sua subclasse. Este tipo de
interação possui acoplamento bastante alto. Assim, faz sentido para um programador tipar mais
tais métodos.
<!--l. 370--><p class="indent" >       <hr class="figure"><div class="figure" 
>

<a 
 id="x1-10001r3"></a>


<!--l. 371--><p class="noindent" ><img 
src="2_Users_carlosgsouza_Dropbox_UFMG_Mestrado_mes_artigo_visibilidade.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figura&#x00A0;3: </span><span  
class="content">Sistemas de Tipo por Visibildiade da Declaração</span></div><!--tex4ht:label?: x1-10001r3 -->

<!--l. 376--><p class="indent" >       </div><hr class="endfigure">
<a 
 id="x1-10002r14"></a>
<h4 class="subsectionHead"><span class="titlemark">4.4.  </span> <a 
 id="x1-110004"></a>Resultados por Tamanho de Projeto</h4>
<!--l. 382--><p class="noindent" >O número de linhas de código é uma das métricas mais simples para definir a complexidade de
um projeto. Foram correlacionadas as quantidade relativas de cada tipo de declaração com o
tamanho tamanho de cada projeto. Assim, é possível entender se a complexidade de um projeto
influencia no sistema de tipos escolhido pelo programador. A figura <a 
href="#x1-11001r4">4<!--tex4ht:ref: fig:tamanho --></a> mostra que existe uma
correlação bastante significativa entre o uso de declarações tipadas em retornos e parâmetros de
métodos públicos com o tamanho do projeto. Programadores tendem a se preocupar mais
com a interface de seus módulos à medida que a complexidade do projeto cresce.
Não foi possível observar nenhuma outra tendência significativa para outros tipos de
declarações.
<!--l. 394--><p class="indent" >       <hr class="figure"><div class="figure" 
>

<a 
 id="x1-11001r4"></a>


<!--l. 395--><p class="noindent" ><img 
src="3_Users_carlosgsouza_Dropbox_UFMG_Mestrado_mes_artigo_tamanho.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figura&#x00A0;4: </span><span  
class="content">Sistemas de tipo de retornos e parâmetros de métodos públicos agrupados por
tamanho de projeto. O ranking de Spearman para a relação entre tamanho de projeto e
uso de declarações com tipo para este tipo de declaração é de 0.95.</span></div><!--tex4ht:label?: x1-11001r4 -->

<!--l. 403--><p class="indent" >       </div><hr class="endfigure">
<a 
 id="x1-11002r16"></a>
<h4 class="subsectionHead"><span class="titlemark">4.5.  </span> <a 
 id="x1-120005"></a>Scripts e Testes</h4>
<!--l. 409--><p class="noindent" >As tabelas <a 
href="#x1-12001r2">2<!--tex4ht:ref: tab:teste --></a> e <a 
href="#x1-12002r3">3<!--tex4ht:ref: tab:script --></a> mostram o uso de sistemas de tipos agrupados entre classes de teste/classes
funcionais e classes/scripts. Aparentemente, classes de teste e scripts não influenciam na escolha
pelo sistema de tipos.
       <div class="table">

<!--l. 415--><p class="indent" >       <a 
 id="x1-12001r2"></a><hr class="float"><div class="float" 
>

 <div class="caption" 
><span class="id">Tabela&#x00A0;2: </span><span  
class="content">Declarações em Groovy agrupadas por classes de teste e classes funcionais</span></div><!--tex4ht:label?: x1-12001r2 -->
<div class="tabular"> <table id="TBL-4" class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
><colgroup id="TBL-4-1g"><col 
id="TBL-4-1"></colgroup><colgroup id="TBL-4-2g"><col 
id="TBL-4-2"></colgroup><colgroup id="TBL-4-3g"><col 
id="TBL-4-3"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-1-"><td  style="white-space:nowrap; text-align:center;" id="TBL-4-1-1"  
class="td11">            </td><td  style="white-space:nowrap; text-align:center;" id="TBL-4-1-2"  
class="td11">Tipagem Estática</td><td  style="white-space:nowrap; text-align:center;" id="TBL-4-1-3"  
class="td11">Tipagem Dinâmica</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-2-"><td  style="white-space:nowrap; text-align:center;" id="TBL-4-2-1"  
class="td11"> Classes de Teste  </td><td  style="white-space:nowrap; text-align:center;" id="TBL-4-2-2"  
class="td11">    57%          </td><td  style="white-space:nowrap; text-align:center;" id="TBL-4-2-3"  
class="td11">     43%            </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-3-"><td  style="white-space:nowrap; text-align:center;" id="TBL-4-3-1"  
class="td11">Classes Funcionais</td><td  style="white-space:nowrap; text-align:center;" id="TBL-4-3-2"  
class="td11">    62%          </td><td  style="white-space:nowrap; text-align:center;" id="TBL-4-3-3"  
class="td11">     38%            </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-4-"><td  style="white-space:nowrap; text-align:center;" id="TBL-4-4-1"  
class="td11">             </td></tr></table></div>

       </div><hr class="endfloat" />
       </div>
       <div class="table">

<!--l. 439--><p class="indent" >       <a 
 id="x1-12002r3"></a><hr class="float"><div class="float" 
>

 <div class="caption" 
><span class="id">Tabela&#x00A0;3: </span><span  
class="content">Declarações em Groovy agrupadas em classes e scripts</span></div><!--tex4ht:label?: x1-12002r3 -->
<div class="tabular"> <table id="TBL-5" class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
><colgroup id="TBL-5-1g"><col 
id="TBL-5-1"></colgroup><colgroup id="TBL-5-2g"><col 
id="TBL-5-2"></colgroup><colgroup id="TBL-5-3g"><col 
id="TBL-5-3"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-5-1-"><td  style="white-space:nowrap; text-align:center;" id="TBL-5-1-1"  
class="td11">     </td><td  style="white-space:nowrap; text-align:center;" id="TBL-5-1-2"  
class="td11">Tipagem Estática</td><td  style="white-space:nowrap; text-align:center;" id="TBL-5-1-3"  
class="td11">Tipagem Dinâmica</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-5-2-"><td  style="white-space:nowrap; text-align:center;" id="TBL-5-2-1"  
class="td11">Classes</td><td  style="white-space:nowrap; text-align:center;" id="TBL-5-2-2"  
class="td11">    61%          </td><td  style="white-space:nowrap; text-align:center;" id="TBL-5-2-3"  
class="td11">     39%            </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-5-3-"><td  style="white-space:nowrap; text-align:center;" id="TBL-5-3-1"  
class="td11">Scripts</td><td  style="white-space:nowrap; text-align:center;" id="TBL-5-3-2"  
class="td11">    54%          </td><td  style="white-space:nowrap; text-align:center;" id="TBL-5-3-3"  
class="td11">     46%            </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-5-4-"><td  style="white-space:nowrap; text-align:center;" id="TBL-5-4-1"  
class="td11">     </td></tr></table></div>

       </div><hr class="endfloat" />
       </div>
<a 
 id="x1-12003r9"></a>
<h3 class="sectionHead"><span class="titlemark">5.  </span> <a 
 id="x1-130005"></a>Ameaças à Validade</h3>
<!--l. 467--><p class="noindent" >Este trabalho se baseia na hipótese de que programadores irão escolher, para cada situação,
o melhor sistema de tipos. Essa hipótese porem não é muito robusta. Em primeiro
lugar, não existe um conceito único do que é melhor para cada situação. Por exemplo,
um programador pode entender que declarações em classes de teste precisam ser
tipadas uma vez que teste automatizado atua tambem como documentação. Outro
programador pode preferir declarar variáveis sem tipo em classes de teste pois acredita
que código de teste, por não agregar valor funcional, deve ser simples e rápido de se
escrever.
<!--l. 477--><p class="indent" >       Há diversos fatores difíceis de se medir que podem influenciar a escolha
de tipos. Alguns frameworks exigem que o programador use um determinado
sistema de tipos. Uma das maneiras de se criar mocks usando o framwork de testes
Spock<span class="footnote-mark"><a 
href="sbc-template4.html#fn3x0"><sup class="textsuperscript">3</sup></a></span><a 
 id="x1-13001f3"></a>,
por exemplo, exige que o programador declare seu mock usando tipos estáticos. Programadores
podem ter maior experiência em linguagens com um determinado sistema de tipos e continuar a
usando esse mesmo sistema de tipos em Groovy. Em particular, programadores Java que
começam a usar Groovy pela semelhança entre as linguagens continuam usando tipos em suas
declarações com bastante frequência.
<!--l. 489--><p class="indent" >       Dadas as ameaças listadas acima, este trabalho evita tecer quaisquer tipos de conclusões
definitivas a respeito de qual sistema de tipos é melhor para cada situação. Ao invés disso, são
discutidas possíveis causas para cada resultado observado
<a 
 id="x1-13002r21"></a>
<h3 class="sectionHead"><span class="titlemark">6.  </span> <a 
 id="x1-140006"></a>Conclusão e Trabalhos FuturosReferences</h3>
<!--l. 497--><p class="noindent" >Este trabalho caracteriza como sistemas de tipos são utilizados em Groovy. Resultados
mostraram que declarações com tipo são, em geral, mais frequentes na maioria dos casos. O
único tipo de declaração onde o uso de sistema de tipos dinâmico é mais comum são as
declarações de variáveis locais, onde o escopo limitado e a proximidade da criação de uma
variável fazem o uso de declarações tipadas muitas vezes desnecessário. Não há diferença
significativa no uso do sistema de tipos entre classes e scripts ou entre classes funcionais e
classes de teste.
<!--l. 506--><p class="indent" >       De forma geral, pode se observar que o uso do sitema de tipos estático é mais frequente
em declarações mais importantes para o correto funcionamento do sistema, tais como métodos e
campos públicos, que definem a interface de um módulo, ou métodos protegidos, que definem
um contrato com alto acoplamento entre uma classe e suas subclasses. Foi possível ainda
visualizar um crescimento no uso de declarações tipadas em métodos públicos à medida que o
tamanho dos projetos cresce. Tal observação é um indício de que programadores consideram

declarações tipadas mais robustas.
<!--l. 516--><p class="indent" >       Este trabalho é apenas a primeira parte de um trabalho mais completo, cujo objetivo é
analisar como sistemas de tipos influenciam o desenvolvimento de software. Em particular,
deseja-se responder as seguintes questões:
       <ul class="itemize1">
       <li class="itemize">Variáveis declaradas sem tipo possuem maior correlação com o aparecimento de
       defeitos no sistema?
       </li>
       <li class="itemize">Variáveis declaradas sem informação de tipo prejudicam a manutenibilidade?
       </li>
       <li class="itemize">Quais fatores influenciam na decisão pelo sistema de tipos?
       </li>
       <li class="itemize">É possível construir grandes sistemas a partir de linguagens com sistemas de tipo
       dinâmicos?</li></ul>
<!--l. 527--><p class="noindent" >O dataset e a metodologia utilizados neste trabalho serão utilizados em trabalhos futuros para responder
as questões acima. Há ainda a necessidade de desenvolver novos tipos de análises, como o
estudo do histórico do sistema e o relacionamento entre o uso de sistemas de tipos e métricas de
software.

<a 
 id="Q1-1-23"></a>
<h3 class="likesectionHead"><a 
 id="x1-150006"></a>Referências</h3>
   <div class="thebibliography">
   <p class="bibitem" ><span class="biblabel">
<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xbruce2002foundations"></a>Bruce, K. (2002).   <span 
class="ptmri7t-x-x-120">Foundations of object-oriented languages: types and semantics</span>.
   MIT press.
   </p>
   <p class="bibitem" ><span class="biblabel">
<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xtype_systems"></a>Cardelli, L. (1996). Type systems. <span 
class="ptmri7t-x-x-120">ACM Comput. Surv.</span>, 28(1):263&#8211;264.
   </p>
   <p class="bibitem" ><span class="biblabel">
<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xjit"></a>Chang, M., Mathiske, B., Smith, E., Chaudhuri, A., Gal, A., Bebenita, M., Wimmer,
   C., and Franz, M. (2011).  The impact of optional type information on jit compilation
   of dynamically typed languages. <span 
class="ptmri7t-x-x-120">SIGPLAN Not.</span>, 47(2):13&#8211;24.
   </p>
   <p class="bibitem" ><span class="biblabel">
<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xruby_vs_druby"></a>Daly, M.&#x00A0;T., Sazawal, V., and Foster, J.&#x00A0;S. (2009).  Work In Progress: an Empirical
   Study  of  Static  Typing  in  Ruby.     In  <span 
class="ptmri7t-x-x-120">Workshop  on  Evaluation  and  Usability  of</span>
   <span 
class="ptmri7t-x-x-120">Programming Languages and Tools (PLATEAU)</span>, Orlando, Florida.
   </p>
   <p class="bibitem" ><span class="biblabel">
<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XGannon:1977:EED:359763.359800"></a>Gannon,  J.&#x00A0;D.  (1977).     An  experimental  evaluation  of  data  type  conventions.
   <span 
class="ptmri7t-x-x-120">Commun. ACM</span>, 20(8):584&#8211;595.
   </p>
   <p class="bibitem" ><span class="biblabel">
<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xexperiment_with_purity"></a>Hanenberg, S. (2010).  An experiment about static and dynamic type systems: doubts
   about the positive impact of static type systems on development time.  <span 
class="ptmri7t-x-x-120">SIGPLAN Not.</span>,
   45(10):22&#8211;35.
   </p>
   <p class="bibitem" ><span class="biblabel">
<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xhanenberg_icpc"></a>Kleinschmager,  S.,  Hanenberg,  S.,  Robbes,  R.,  and  Stefik,  A.  (2012).    Do  static
   type systems improve the maintainability of software systems? An empirical study.
   <span 
class="ptmri7t-x-x-120">2012 20th IEEE International Conference on Program Comprehension (ICPC)</span>, pages
   153&#8211;162.
   </p>
   <p class="bibitem" ><span class="biblabel">
<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xtypes_and_programming_languages"></a>Pierce, B. (2002). <span 
class="ptmri7t-x-x-120">Types and programming languages</span>. MIT press.
   </p>
   <p class="bibitem" ><span class="biblabel">
<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xtype_sytems_in_parameters"></a>Prechelt, L. and Tichy, W.&#x00A0;F. (1998).  A controlled experiment to assess the benefits
   of procedure argument type checking.  <span 
class="ptmri7t-x-x-120">IEEE Transactions on Software Engineering</span>,
   24:302&#8211;312.
   </p>

   <p class="bibitem" ><span class="biblabel">
<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xeval_js"></a>Richards,  G.,  Hammer,  C.,  Burg,  B.,  and  Vitek,  J.  (2011).   The  eval  that  men  do.
   In Mezini, M., editor, <span 
class="ptmri7t-x-x-120">ECOOP 2011 Object-Oriented Programming</span>, volume 6813 of
   <span 
class="ptmri7t-x-x-120">Lecture Notes in Computer Science</span>, pages 52&#8211;78. Springer Berlin Heidelberg.
   </p>
   <p class="bibitem" ><span class="biblabel">
<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xdynamically_typed_languages"></a>Tratt, L. (2009).  Chapter 5 dynamically typed languages.  volume&#x00A0;77 of <span 
class="ptmri7t-x-x-120">Advances in</span>
   <span 
class="ptmri7t-x-x-120">Computers</span>, pages 149 &#8211; 184. Elsevier.
</p>
   </div>
        
</body></html> 



