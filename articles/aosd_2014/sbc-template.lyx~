#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble


\usepackage{sbc-template}

\usepackage{url}

\usepackage[brazil]{babel}   


     
\sloppy

\title{A study of which factors influence the coice for a static or a dynamic typing system}

\author{Carlos Souza, Eduardo Magno Figueiredo, Marco Tulio Oliveira Valente}


\address{Departament of Computer Science, UFMG, Brazil
  \email{carlos.garcia@dcc.ufmg.br, figueiredo@dcc.ufmg.br, mtov@dcc.ufmg.br}
}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding latin1
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
maketitle
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
Over the last years, dynamically typed languages such as Python, Ruby and
 JavaScript are becoming more popular in the software industry, previously
 dominated by statically typed languages.
 With more options, choosing the ideal language for each situation can become
 a complex task.
 In this paper we study which factors influence the choice of a programmer
 for a programming language when considering its typing system.
 We analyze the source code of more than one thousand projects written in
 Groovy, a language that allows programmers to choose between dynamic and
 static typing for each declaration.
 This analysis makes it possible to understand, for which types of declaration,
 programmers favor static or dynamic typing.
 Results show that Groovy programmers prefer static typing in most cases,
 specially when software maintenance is critical.
\end_layout

\begin_layout Section
Introdução
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Tem que falar pro leitor que Groovy é diferente.
 A gente vai ensinar o cara sobre qual sistema de tpos é melhor pra cada
 situação, mas na maioria das linguages o programador não pode escolher
 o sistema de tipos pra uma situação, ele escolhe o da linguagem inteira
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Linguagens de programação com tipagem dinâmica tem se tornado cada vez mais
 populares na indústristra de software nos últimos anos.
 De acordo com o TIOBE Programming Community Index
\begin_inset Foot
status open

\begin_layout Plain Layout
www.tiobe.com/index.php/content/paperinfo/tpci/index.html
\end_layout

\end_inset

, um conhecido ranking que mede a popularidade de linguagens de programação,
 27% das linguagens de programação adotadas na indústria possuem tipagem
 dinâmica.
 Em 2001, esse número era de apenas 17%.
 Entre as 10 linguagens no topo do ranking, 4 possuem sistemas de tipos
 dinâmicos: Ruby, Perl, Python e PHP.
 Em 1997, dentre essas linguagens, apenas Python e Perl apareciam no ranking,
 em 29º e 7º lugares respectivamente.
 
\end_layout

\begin_layout Standard
Linguagens com tipagem dinâmica possuem algumas vantagens sobre aquelas
 com tipagem estática.
 Por serem mais simples, os programadores conseguem executar suas tarefas
 de desenvolvimento mais rapidamente.
 Ainda, ao removerem o trabalho burocrático e repetitivo de declarar os
 tipos das variáveis, estas linguagens permitem que seus usuários foquem
 no problema a ser resolvido, ao invés de se preocuparem com as regras da
 linguagem 
\begin_inset CommandInset citation
LatexCommand cite
key "jit,dynamically_typed_languages"

\end_inset

.
\end_layout

\begin_layout Standard
Por outro lado, sistemas de tipos estáticos, também possuem suas vantagens.
 Estes conseguem prevenir erros de tipo em tempo de compilação.
 Pode-se argumentar que declarações de tipos aumentam a manutenibilidade
 de sistemas pois estas atuam como documentação, informando ao programador
 sobre a natureza de cada variável.
 Alem disso, sistemas escritos a partir desse destas linguagens tendem a
 ser mais eficientes, uma vez que não precisam realizar checagem de tipo
 durante a execução
\begin_inset CommandInset citation
LatexCommand cite
key "type_systems,types_and_programming_languages,bruce2002foundations"

\end_inset

 .
\end_layout

\begin_layout Standard
Embora muito tenha se discutido a respeito das vantagens e desvantagens
 de sistemas de tipos estáticos ou dinâmicos, há poucas evidências a respeito
 da real influência destes sobre a evolução de sistemas de software.
 Alguns trabalhos 
\begin_inset CommandInset citation
LatexCommand cite
key "experiment_with_purity,type_sytems_in_parameters,ruby_vs_druby"

\end_inset

 chegam a tentar analisar essa questão através de estudos controlados, mas
 esses não são capazes de reproduzir com precisão o contexto da indústria
 de software e portanto não são muito confiáveis.
 
\end_layout

\begin_layout Standard
Este artigo apresenta uma análise de como programadores usam sistemas de
 tipo em Groovy, uma linguagem com sistemas híbrido.
 Em Groovy, um programador pode escolher, para cada declaração, se utilizará
 tipagem dinâmica ou estática.
 Assim, espera-se que programadores escolham para cada situação o sistema
 de tipos mais adequado.
 Ao analisar como estes programadores usam sistemas de tipo, é possível
 entender quais fatores influenciam nessa decisão.
 Essa informação é capaz de ajudar desenvolvedores na escolha de linguagens
 de programação de acordo com o contexto em que se encontram.
 Projetistas de linguagens tambem podem se beneficiar desse conhecimento
 ao entenderem melhor como sistemas de tipos são usados.
\end_layout

\begin_layout Section
The Groovy language
\end_layout

\begin_layout Standard
Groovy is an object oriented programming language designed for the Java
 platform.
 Its syntax is based on Java's, but it also features dynamic functionalities
 similar to those of Ruby and Python such as metaprogramming and closures.
 Its adoption has been growing exceptionally fast over the last years, specially
 among Java developers.
 Despite having had its first official release only in 2007, Groovy is currently
 ranked as the 36
\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

 most popular programming language by the TIOBE Programming Community Index
\begin_inset CommandInset citation
LatexCommand cite
key "tiobeIndex"

\end_inset

.
 A Groovy programmer is allowed to choose between static or dynamic typing
 for each one of his declarations independently.
 It's possible, for example, to define the return type of a method while
 keeping the parameters of the same method dynamically typed as shown in
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "codigoGroovy"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Integer add(a, b) {
\end_layout

\begin_layout Plain Layout

	return a+b
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A method written in Groovy
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "codigoGroovy"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Configuração do Estudo
\end_layout

\begin_layout Standard
O estudo apresentado neste trabalho consite em analisar o uso de sistemas
 de tipos estático e dinâmico em um conjunto de projetos escritos utilizando
 a linguagem Groovy.
 A escolha por um destes sistemas é relacionada com fatores como o tamanho
 do projeto, tipo de declaração, visibilidade da declaração, entre outros.
 O objetivo é descobrir quais fatores os desenvolvedores consideram importantes
 na hora de escolher um sistema de tipos.
 Este estudo baseia-se na hipótese de que, dado que um programador é livre
 para escolher o sistema de tipos para cada declaração individualmente,
 ele irá sempre escolher o melhor sistema de tipos para cada situação encontrada.
 A seção 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ameaca"

\end_inset

 discute algumas ameaças à validade desta hipótese.
\end_layout

\begin_layout Subsection
Dataset
\end_layout

\begin_layout Standard
All projects used in our analysis were retrieved from GitHub 
\begin_inset CommandInset citation
LatexCommand cite
key "github"

\end_inset

, a source management service based on Git 
\begin_inset CommandInset citation
LatexCommand cite
key "gitBook"

\end_inset

 very popular among Groovy developers.
 Thanks to the GitHub API
\begin_inset CommandInset citation
LatexCommand cite
key "githubAPI"

\end_inset

, it was possible to find and download the source code of almost two thousand
 Groovy projects.
 After discarding private and forked projects, our dataset contains 1112
 projects with a total of 1.676MLOC, considering only the last version of
 each system.
 The distribution of the size of each project, in lines of code, is displayed
 on Figure 
\begin_inset Float figure
placement ht
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset Graphics
	filename size_distribution.png
	width 50text%

\end_inset

 
\begin_inset Caption

\begin_layout Plain Layout
Distribuição dos 1112 projetos utilizados por tamanho do projeto em LOC.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:size_distribution"

\end_inset

 
\end_layout

\end_inset

.
 These projects have been written by 926 developers.
 The sum of the age of all projects exceeds 300 years.
\end_layout

\begin_layout Subsection
Static code analyser
\end_layout

\begin_layout Standard
Para obter os sistemas de tipos utilizados em cada declaração foi implementado
 um analisador estático de código baseado na API de manipulação de ASTs
\begin_inset Foot
status open

\begin_layout Plain Layout
http://groovy.codehaus.org/Compile-time+Metaprogramming+-+AST+Transformations
 (visitado em 10 de Dezembro de 2012
\end_layout

\end_inset

 de Groovy.
 Esta API permite ao programador modificar em tempo de compilação o código
 gerado pelo programa.
 Em outras palavras, é possível programar o compilador.
 É possível ainda navegar pela AST gerada para cada uma das fases do compilador
 para um módulo Groovy.
 A fase escolhida para recolher informações sobre os sistemas de tipos utilizado
s foi a de Conversão.
 Nesta fase, já é possível acessar todas as declarações escritas pelo programado
r, porem o compilador ainda não tentou resolver referências a outros tipos.
 Sendo assim, o analisador estático consegue analisar cada arquivo separadamente
, sem precisar resolver nenhuma dependência externa.
\end_layout

\begin_layout Standard
Para cada classe ou script escrito em Groovy, são obtidas informações dos
 seguintes tipos de declarações
\end_layout

\begin_layout Itemize
Retorno de Método
\end_layout

\begin_layout Itemize
Parâmetro de Método
\end_layout

\begin_layout Itemize
Parâmetro de Construtor
\end_layout

\begin_layout Itemize
Campo
\end_layout

\begin_layout Itemize
Variável Local
\end_layout

\begin_layout Standard
Cada um dos tipos de declaração acima é agrupado por visibilidade, pública,
 privada ou protegida.
 É guardado ainda, para cada classe, se esta classe é um script ou a implementaç
ão de um teste automatizado.
\end_layout

\begin_layout Section
Resultados
\end_layout

\begin_layout Subsection
Resultado Geral
\end_layout

\begin_layout Standard
A tabela 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:geral"

\end_inset

 mostra o valor relativo do uso dos sistemas de tipos considerando todas
 as declarações.
 Esta tabela mostra que, no geral, programadores preferm utilizar tipagem
 estática.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Declarações em Groovy
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tipagem Estática
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tipagem Dinâmica
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Geral
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40%
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:geral"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Resultados por Tipo de Declaralção
\end_layout

\begin_layout Standard
A figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:tipo_declaracao"

\end_inset

 mostra a quantidade relativa de declarações agrupadas por tipo de declaração.
 Variáveis locais utilizam tipagem dinâmica com mais frequência que outros
 tipos de declarações.
 Esse resultado já era esperado já que este tipo de variável possui menor
 escopo e ciclo de vida.
 Programadores não precisam se preocupar tanto em tipar essas variáveis
 já que elas não afetam outras partes do programa.
 Alem disso, por serem criadas localmente, o tipo destas variáveis pode
 ser facilmente inferido por programadores que venham a trabalhar com essas
 variáveis.
\end_layout

\begin_layout Standard
Os tipos de declaração mais estaticamente tipados são os parâmetros de construto
res.
 Pode se argumentar que há uma preocupação maior dos desenvolvedores em
 definir a interface dos métodos construtores uma vez que estes métodos
 definem a própria criação de um objeto e, caso não sejam invocados corretamente
, podem comprometer o funcionamento desta instância.
 Outra possível explicação é que, como construtores tem o tipo de retorno
 tipado estaticamente por definição, programadores acabem tipando os parâmetros
 por coerência.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement ht
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset Graphics
	filename tipo.png
	width 50text%

\end_inset

 
\begin_inset Caption

\begin_layout Plain Layout
Sistemas de Tipo por Tipo de Declaração.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:tipo_declaracao"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Resultados por Visibilidade
\end_layout

\begin_layout Standard
O gráfico da figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:visibilidade"

\end_inset

 mostra o uso de sistema de tipos por visibilidade de cada declaração.
 Repare que declarações públicas são estaticamente tipadas com mais frequência.
 Isto demonstra uma maior preocupação de desenvolvedores em tipar métodos
 e campos que compões a interface de um módulo.
 Outro resultado interessante é que métodos protegidos são tipados com muita
 frequência.
 Em geral, métodos protegidos são utilizados como uma maneira de delegar
 parte da implementação necessária a uma super classe para a sua subclasse.
 Este tipo de interação possui acoplamento bastante alto.
 Assim, faz sentido para um programador tipar mais tais métodos.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement ht
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset Graphics
	filename visibilidade.png
	width 70text%

\end_inset

 
\begin_inset Caption

\begin_layout Plain Layout
Sistemas de Tipo por Visibildiade da Declaração
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:visibilidade"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Resultados por Tamanho de Projeto
\end_layout

\begin_layout Standard
O número de linhas de código é uma das métricas mais simples para definir
 a complexidade de um projeto.
 Foram correlacionadas as quantidade relativas de cada tipo de declaração
 com o tamanho tamanho de cada projeto.
 Assim, é possível entender se a complexidade de um projeto influencia no
 sistema de tipos escolhido pelo programador.
 A figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:tamanho"

\end_inset

 mostra que existe uma correlação bastante significativa entre o uso de
 declarações tipadas em retornos e parâmetros de métodos públicos com o
 tamanho do projeto.
 Programadores tendem a se preocupar mais com a interface de seus módulos
 à medida que a complexidade do projeto cresce.
 Não foi possível observar nenhuma outra tendência significativa para outros
 tipos de declarações.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement ht
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset Graphics
	filename tamanho.png
	width 80text%

\end_inset

 
\begin_inset Caption

\begin_layout Plain Layout
Sistemas de tipo de retornos e parâmetros de métodos públicos agrupados
 por tamanho de projeto.
 O ranking de Spearman para a relação entre tamanho de projeto e uso de
 declarações com tipo para este tipo de declaração é de 0.95.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:tamanho"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Scripts e Testes
\end_layout

\begin_layout Standard
As tabelas 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:teste"

\end_inset

 e 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:script"

\end_inset

 mostram o uso de sistemas de tipos agrupados entre classes de teste/classes
 funcionais e classes/scripts.
 Aparentemente, classes de teste e scripts não influenciam na escolha pelo
 sistema de tipos.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Declarações em Groovy agrupadas por classes de teste e classes funcionais
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tipagem Estática
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tipagem Dinâmica
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Classes de Teste
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
57%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
43%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Classes Funcionais
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
62%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
38%
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:teste"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Declarações em Groovy agrupadas em classes e scripts
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tipagem Estática
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tipagem Dinâmica
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Classes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
61%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
39%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Scripts
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
54%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
46%
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:script"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Threatens to Validity
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:ameaca"

\end_inset


\end_layout

\begin_layout Standard
This work relies on the hypothesis that Groovy programmers will choose the
 most apropriate typing system for each situation, however there is not
 a single definition for what is the best typing system for all situations.
 For example, one may believe that unit test variables should be statically
 typed as a means to document the code while another might prefer dynamically
 typed variables since they make coding tasks simpler.
 However, ee have found that, for some delcarations such as those of local
 variables and public methods or fields, there is a clear tendency of developers
 to choose the same typing system.
\end_layout

\begin_layout Standard
Some frameworks impose the use of a given typing system.
 For example, one of the mocking mechanisms available in Spock
\begin_inset CommandInset citation
LatexCommand cite
key "spock"

\end_inset

, a test automation framework popular among Groovy developers, requires
 the programmer to statically type the mock variable.
 However, due to the big number and heterogenity of projects analysed, we
 haven't found any heavily used frameworks that could influence the overall
 results.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
this is terrible
\end_layout

\end_inset

Programmers with previous experience in languages with a given type system
 might keep using the same type system in Groovy.
 Since there is a huge number of Java programmers which have migrated to
 Groovy, there is a risk that our analysis is impacted by that.
\end_layout

\begin_layout Standard
used to type their declarations, might continue doing the same in Groovy.
 Still, we can see clearly that for declarations such as those of local
 variables, there is a strong 
\end_layout

\begin_layout Standard
Given the threatens listed above, we avoid any kinds of conclusion about
 what is the best typing system, but try to understand what might have taken
 developers to choose a given typing system for each situation.
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard
To the best of our knowledge, there are no studies on the literature that
 try to answer the question of which are the factors that drive the choice
 of a programmer for a static or a dynamic typing system.
 Some studies, however, present a comparison between these two.
 
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset citation
LatexCommand cite
key "experiment_with_purity"

\end_inset

, the author compares the performance of two groups of students when asked
 to develop two small software systems.
 Both groups used a language designed by the authors, Purity, the only differenc
e being that one group used a statically typed version and the other a dynamical
ly typed one.
 The results show that the group using the dynamically typed version of
 Purity was significantly more productive.
 As in our study, the authors were able to compare the two typing systems
 directly, in this case by designing their own language, thus eliminating
 any external factors in the analysis.
 However, it can be argued that these results might not represent the real
 life in the industry precisely since this was a small duration study, consideri
ng programmers as examples of real life programmers, and with no interaction
 with other programmers.
 We try to provide more reliable results by analyzing actual source code
 developed by programmers in their normal activities.
\end_layout

\begin_layout Standard
In a continuation of the previous study 
\begin_inset CommandInset citation
LatexCommand cite
key "hanenberg_icpc"

\end_inset

, the authors came to opposite conclusions.
 They compared the performance of two groups in maintenance tasks, one using
 Java, a statically typed language, and the other, Groovy, enforcing the
 use of dynamically typed declarations only.
 In this case, the group using Java, the statically typed language, was
 much more productive.
 These contradictory results reinforce our argument that studies based on
 source code developed at the industry might yield more reliable results
 than results obtained in controlled studies.
 
\end_layout

\begin_layout Standard
Results similar to the previous study were obtained in 
\begin_inset CommandInset citation
LatexCommand cite
key "type_sytems_in_parameters,Gannon:1977:EED:359763.359800"

\end_inset

.
 These studies however are very old and do not consider newer Software Engineeri
ng tools and practices, which can help programmers to avoid some of the
 common errors in dynamically typed software.
 In our study, the oldest source code dates from 5 years ago, which ensures
 that we don't share the same problem.
\end_layout

\begin_layout Standard
In the experiments performed in 
\begin_inset CommandInset citation
LatexCommand cite
key "ruby_vs_druby"

\end_inset

, the authors study two groups of programmers on small development tasks.
 One group used Ruby, while the other used DRuby, a statically typed version
 of Ruby.
 Results showed that the DRuby compiler rarely catches mistakes that were
 not already evident to programmers.
 Most of the programmers however had previous experience with Ruby and were
 probably used to the lack of typing in their declarations, influencing
 the outcome of this study.
 In our study a similar question can be raised.
 Since most of Groovy programmers have some previous experience with Java,
 they might tend to keep using types in their declarations.
\end_layout

\begin_layout Section
Conclusão e Trabalhos Futuros
\end_layout

\begin_layout Standard
Este trabalho caracteriza como sistemas de tipos são utilizados em Groovy.
 Resultados mostraram que declarações com tipo são, em geral, mais frequentes
 na maioria dos casos.
 O único tipo de declaração onde o uso de sistema de tipos dinâmico é mais
 comum são as declarações de variáveis locais, onde o escopo limitado e
 a proximidade da criação de uma variável fazem o uso de declarações tipadas
 muitas vezes desnecessário.
 Não há diferença significativa no uso do sistema de tipos entre classes
 e scripts ou entre classes funcionais e classes de teste.
\end_layout

\begin_layout Standard
De forma geral, pode se observar que o uso do sitema de tipos estático é
 mais frequente em declarações mais importantes para o correto funcionamento
 do sistema, tais como métodos e campos públicos, que definem a interface
 de um módulo, ou métodos protegidos, que definem um contrato com alto acoplamen
to entre uma classe e suas subclasses.
 Foi possível ainda visualizar um crescimento no uso de declarasções tipadas
 em métodos públicos à medida que o tamanho dos projetos cresce.
 Tal observação é um indício de que programadores consideram declarações
 tipadas mais robustas.
 
\end_layout

\begin_layout Standard
Este trabalho é apenas a primeira parte de um trabalho mais completo, cujo
 objetivo é analisar como sistemas de tipos influenciam o desenvolvimento
 de software.
 Em particular, deseja-se responder as seguintes questões:
\end_layout

\begin_layout Itemize
Variáveis declaradas sem tipo possuem maior correlação com o aparecimento
 de defeitos no sistema?
\end_layout

\begin_layout Itemize
Variáveis declaradas sem informação de tipo prejudicam a manutenibilidade?
\end_layout

\begin_layout Itemize
Quais fatores influenciam na decisão pelo sistema de tipos?
\end_layout

\begin_layout Itemize
É possível construir grandes sistemas a partir de linguagens com sistemas
 de tipo dinâmicos?
\end_layout

\begin_layout Standard
O dataset e a metodologia utilizados neste trabalho serão utilizados em
 trabalhos futuros para responder as questões acima.
 Há ainda a necessidade de desenvolver novos tipos de análises, como o estudo
 do histórico do sistema e o relacionamento entre o uso de sistemas de tipos
 e métricas de software.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "referencias"
options "sbc"

\end_inset


\end_layout

\end_body
\end_document
