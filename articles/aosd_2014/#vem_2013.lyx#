#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{sbc-template}

\usepackage{url}

\usepackage[brazil]{babel}   
     
\sloppy

\title{Tipar ou não tipar? Compreendendo quais Fatores Influenciam a Escolha por um Sistema de Tipos}

\author{Carlos Souza, Eduardo Figueiredo, Marco Tulio Oliveira Valente}


\address{Departamento de Ciência da Computação, UFMG, Brasil
  \email{carlos.garcia@dcc.ufmg.br, figueiredo@dcc.ufmg.br, mtov@dcc.ufmg.br}
}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language brazilian
\language_package none
\inputencoding latin1
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
maketitle
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
One of the most important features to be taken into account when choosing
 a programming language is its typing system, static or dynamic.
 This question has become increasingly more important due to the recent
 popularization of dynamic languages such as Ruby and JavaScript.
 This paper studies which are the most influencing factors for a programmer
 when choosing between typing systems.
 An analysis of the source code of over a thousand projects written in Groovy,
 a programming language where one can choose, for each declaration, either
 to type it or not, shows in which situations programmers prefer a typing
 system over the other.
 Results of this study suggest that the previous experience of the programmer,
 project size, complexity of modules, scope and visibility of statements
 are some of the most important factors in this decision.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{resumo}
\end_layout

\end_inset

 Uma das características mais importantes a serem consideradas na hora de
 se escolher uma linguagem de programação é o seu sistema de tipos, estático
 ou dinâmico.
 Essa questão tem se tornado cada vez mais importante graças à popularização
 recente de linguagens dinamicamente tipadas como Ruby e JavaScript.
 Este trabalho apresenta um estudo sobre quais fatores mais influenciam
 a escolha de um programador por um sistema de tipos.
 Uma análise do código fonte de mais mil projetos escritos em Groovy, uma
 linguagem de programação onde se pode escolher, para cada declaração, usar
 tipos ou não, permite visualizar em quais situações um sistema de tipos
 é preferido.
 Resultados deste estudo apontam que a experiência prévia do programador,
 tamanho do projeto, complexidade dos módulos, escopo e visibilidade das
 declarações são alguns dos fatores mais importantes para essa decisão.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{resumo}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introdução
\end_layout

\begin_layout Standard
Ao se escolher uma linguagem de programação para um projeto, um desenvolvedor
 deve considerar algumas características desta linguagem, sendo uma das
 mais importantes o sistema de tipos.
 Este, que pode ser estático ou dinâmico, define em que momento o tipo de
 uma declaração deve ser definido.
 Declarações em linguagens com tipagem estática, como Java e C#, devem ser
 acompanhadas pela definição de um tipo, que pode ser usado pelo compilador
 para checar a corretude do código.
 Já em linguagens dinamicamente tipadas, como Ruby e JavaScript, a definição
 do tipo só é realizada em tempo de execução.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Ao se escolher uma linguagem de programação para um determinado projeto,
 um desenvolvedor deve considerar diversos fatores, como a disponibilidade
 de ferramentas, bibliotecas e arcabouços, o nível de abstração e o sistema
 de tipos, que pode ser estático ou dinâmico.
 
\end_layout

\begin_layout Plain Layout
Linguagens com tipagem dinâmica, aquelas cuja definição do tipo de uma declaraçã
o só acontece em tempo de execução, têm se tornado cada vez mais populares
 nos últimos anos, o que tem tornado
\end_layout

\begin_layout Plain Layout
Entre as 10 linguagens no topo do ranking, 4 possuem sistemas de tipos dinâmicos
: JavaScript, Perl, Python e PHP.
 Em 1998, nenhuma dessas linguagens estava entre as 10 primeiras.
 Linguagens recentes tem tido adoção extremamente rápida.
 Groovy
\begin_inset CommandInset citation
LatexCommand cite
key "groovySite"

\end_inset

, por exemplo, teve sua primeira versão oficial lançada em 2007 e já ocupa
 a 36
\begin_inset script superscript

\begin_layout Plain Layout
a
\end_layout

\end_inset

 posição posição no ranking, à frente de linguagens como Smalltalk e ActionScrip
t.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A discussão sobre qual sistema de tipos é melhor tem se tornado cada vez
 mais relevante nos últimos anos graças à rápida popularização de linguagens
 dinamicamente tipadas.
 De acordo com o TIOBE Programming Community Index, um conhecido ranking
 que mede a popularidade de linguagens de programação, 27% das linguagens
 de programação adotadas na indústria possuem tipagem dinâmica.
 Em 2001, esse número era de apenas 17%.
 Entre as 10 linguagens no topo do ranking, 4 possuem sistemas de tipos
 dinâmicos: JavaScript, Perl, Python e PHP.
 Em 1998, nenhuma dessas linguagens estava entre as 10 primeiras do ranking.
\end_layout

\begin_layout Standard
Diversos fatores podem ser considerados na escolha por uma linguagem de
 programação com sistema de tipos dinâmico ou estático.
 Linguagens com tipagem dinâmica , por serem mais simples, permitem que
 programadores executem suas tarefas de desenvolvimento mais rapidamente
 Ainda, ao removerem o trabalho de declarar os tipos das variáveis, estas
 linguagens permitem que seus usuários foquem no problema a ser resolvido,
 ao invés de se preocuparem com as regras da linguagem .
\end_layout

\begin_layout Standard
Por outro lado, sistemas de tipos estáticos, também possuem suas vantagens.
 Estes conseguem prevenir erros de tipo em tempo de compilação .
 Declarações de tipos aumentam a manutenibilidade de sistemas pois estas
 atuam como documentação do código, informando ao programador sobre a natureza
 de cada variável .
 Sistemas escritos a partir destas linguagens tendem a ser mais eficientes,
 uma vez que não precisam realizar checagem de tipo durante sua execução.
 Por fim, ambientes de desenvolvimento modernos, tais como Eclipse e IDEA,
 quando possuem conhecimento sobre o tipo de uma declaração, são capazes
 de auxiliar o programador através de funcionalidades como documentação
 e complemento de código .
\end_layout

\begin_layout Standard
Este artigo apresenta um estudo com o objetivo de entender quais dos fatores
 descritos acima influenciam de fato a escolha de um programador por tipar
 ou não as suas declarações.
 A fim de obter resultados confiáveis, essa questão foi estudada tendo como
 base código desenvolvido por programadores no contexto de suas atividades
 cotidianas através da análise de uma massa de dados composta por mais de
 mil projetos.
 Esses projetos foram escritos em Groovy, uma linguagem com sistema de tipos
 híbrido, que permite escolher, para cada declaração, tipá-la ou não.
 Assim, através de uma análise estática dessa massa de dados, é possível
 visualizar quando programadores escolhem cada sistema de tipos e, a partir
 daí, enteder quais são os fatores que influenciam essa decisão.
\end_layout

\begin_layout Standard
O restante deste artigo está organizado da seguinte forma.
 A seção introduz os principais conceitos da linguagem de programação Groovy.
 As seções e descrevem a configuração do estudo e seus resultados.
 Ameaças à validade deste trabalho são discutidas na seção enquanto alguns
 trabalhos relacionados são apresentados na seção.
 Por fim, a seção conclui este trabalho e levanta alguns trabalhos futuros.
\end_layout

\begin_layout Section
A Linguagem Groovy
\begin_inset CommandInset label
LatexCommand label
name "sec:A-Linguagem-Groovy"

\end_inset


\end_layout

\begin_layout Standard
Groovy é uma linguagem de programação orientada a objetos projetada para
 ser executada sobre a plataforma Java, mas com características dinâmicas
 semelhantes às de Ruby e Python.
 Sua adoção tem crescido de maneira notável nos últimos anos e, apesar de
 ter sido lançada há apenas 6 anos, Groovy já é a 36
\begin_inset script superscript

\begin_layout Plain Layout
a
\end_layout

\end_inset

 linguagem mais popular da indústria de software 
\end_layout

\begin_layout Standard
Em Groovy, um programador pode escolher tipar suas declarações ou não.
 Tipagem estática e dinâmica podem ser combinadas no mesmo código livremente.
 No algoritmo , por exemplo, o tipo do retorno do método é definido, enquanto
 os parâmetros e a variável local são tipados dinamicamente.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Float algorithm
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

1.
  Integer add(a, b) {
\end_layout

\begin_layout Plain Layout

2.
      def c = a + b
\end_layout

\begin_layout Plain Layout

3.
  	return c
\end_layout

\begin_layout Plain Layout

4.
  }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Um método escrito em Groovy
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "codigoGroovy"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A maior parte da linguagem Java também é válida em Groovy e código Groovy
 pode interagir diretamente com código Java e vice-versa.
 Esses fatores tem atraído um grande número de programadores Java que desejam
 utilizar suas funcionalidades sem ter que aprender uma linguagem completamente
 diferente ou mudar a plataforma de execução de seus sistemas.
 Outros recursos interessantes de Groovy são suporte nativo a coleções,
 possibilidade de se escrever scripts e metaprogramação.
 
\end_layout

\begin_layout Section
Configuração do Estudo
\begin_inset CommandInset label
LatexCommand label
name "sec:Configuração-do-Estudo"

\end_inset


\end_layout

\begin_layout Standard
Este trabalho analisa em quais declarações programadores preferem utilizar
 tipagem estática ou dinâmica a fim de entender quais fatores influenciam
 nessa escolha.
 Abaixo são descritos a massa de dados e o analisador estático usados para
 tal.
\end_layout

\begin_layout Subsection
Massa de Dados
\begin_inset CommandInset label
LatexCommand label
name "sub:Massa-de-Dados"

\end_inset


\end_layout

\begin_layout Standard
Os projetos utilizados neste estudo foram obtidos do GitHub, um serviço
 de controle de versão baseado em Git.
 Utilizando a API do GitHub, foi possível obter o código fonte de quase
 dois mil projetos Groovy.
 Após descartar projetos privados e duplicados, restaram 1112 projetos com
 um total de 1,67 milhões de linhas de código, considerando apenas a última
 versão de cada projeto.
 A distribuição do tamanho destes projetos é mostrada na figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:size_distribution"

\end_inset

.
 Estes sistemas foram desenvolvidos por um total de 926 programadores.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement ht
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset Graphics
	filename ../vem_2013/size_distribution.png
	width 50text%

\end_inset

 
\begin_inset Caption

\begin_layout Plain Layout
Distribuição do tamanho dos projetos
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:size_distribution"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
puxar saco do meu dataset
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Analisador de código estático
\end_layout

\begin_layout Standard
O analisador de código estático utilizado neste trabalho é baseado na biblioteca
 de metaprogramação de Groovy.
 Com esta biblioteca, é possível criar uma árvore sintática abstrata(AST)
 a partir de código fonte utilizando uma das diversas fases do próprio compilado
r de Groovy.
 A fase escolhida foi a de de conversão, que possui informação suficiente
 para determinar o sistema de tipos de cada declaração.
 Essa fase acontece antes do compilador tentar resolver quaisquer dependências
 externas, tornando possível analisar cada arquivo separadamente sem que
 seja necessário compilar o projeto.
\end_layout

\begin_layout Standard
Os seguintes tipos de declarações podem ser analisados
\end_layout

\begin_layout Itemize
Retorno de Métodos
\end_layout

\begin_layout Itemize
Parâmetros de Métodos
\end_layout

\begin_layout Itemize
Parâmetros de Construtores
\end_layout

\begin_layout Itemize
Campos
\end_layout

\begin_layout Itemize
Variáveis Locais
\end_layout

\begin_layout Standard
Para cada item listado acima, é possível obter ainda as seguintes informações
\end_layout

\begin_layout Itemize
A declaração é parte de um script ou de uma classe?
\end_layout

\begin_layout Itemize
A declaração é parte de uma classe de testes?
\end_layout

\begin_layout Itemize
Visibilidade (exceto para variáveis locais)
\end_layout

\begin_layout Section
Resultados
\begin_inset CommandInset label
LatexCommand label
name "sec:Resultados"

\end_inset


\end_layout

\begin_layout Standard
A seguir são apresentados os resultados deste trabalho.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
A análise do código fonte dos 1112 projetos mostra que programadores Groovy
 preferem usar tipagem estática na maioria dos casos.
 Essa preferência se torna ainda mais evidente em declarações que definem
 a interface de um módulo, como campos e métodos públicos ou protegidos.
 É possível ainda perceber que projetos grandes tendem a usar mais tipagem
 estática que projetos menores.
 Variáveis locais são o único tipo de declaração onde tipagem dinâmica é
 mais frequente que estática.
 Esses resultados são discutidos em detalhes a seguir.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Conclusão dos resultados
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Resultado Geral
\begin_inset CommandInset label
LatexCommand label
name "sub:Resultado-Geral"

\end_inset


\end_layout

\begin_layout Standard
Cerca de 60% das declarações são estaticamente tipadas, enquanto apenas
 40% destas são dinamicamente tipadas.
 Dado que grande parte dos programadores Groovy eram previamente programadores
 Java e, portanto, estavam acostumados com tipagem estática, este resultado
 sugere que a experiência prévia de um programador é um fator importante
 na escolha do sistema de tipos.
\end_layout

\begin_layout Subsection
Resultados por Tipo de Declaração
\begin_inset CommandInset label
LatexCommand label
name "sub:Resultados-por-Tipo"

\end_inset


\end_layout

\begin_layout Standard
A figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:tipo_declaracao"

\end_inset

 mostra que tipagem dinâmica é utilizada em declarações de variáveis locais
 com muito mais frequência que em outros tipos de declaração.
 Dado que variáveis locais possuem menor escopo e menor ciclo de vida, programad
ores provavelmente sentem menor necessidade de documentá-las através da
 definição de tipos e acabam optando pela maneira mais direta de declará-las.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement ht
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset Graphics
	filename ../vem_2013/tipo.png
	width 75text%

\end_inset

 
\begin_inset Caption

\begin_layout Plain Layout
Sistemas de Tipo por Tipo de Declaração.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:tipo_declaracao"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Por outro lado, parâmetros de construtores são o tipo de declaração mais
 frequentemente tipado.
 Pode se argumentar que há uma preocupação grande em tipar (e documentar)
 construtores uma vez que estes são importantes elementos da definição do
 contrato de um módulo.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Por fim, pode-se observar que existe uma preocupação maior em garantir as
 pré-condições de métodos, através da tipagem de parâmetros, do que em garantir
 as pós-condições, através da tipagem de retornos.
 Aparentemente, programadores se preocupam mais com o correto funcionamento
 dos módulos que estão desenvolvendo do que com o dos clientes deste módulo.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Resultados por Visibilidade
\begin_inset CommandInset label
LatexCommand label
name "sub:Resultados-por-Visibilidade"

\end_inset


\end_layout

\begin_layout Standard
De acordo com a figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:visibilidade"

\end_inset

, declarações com visibilidade pública ou protegida são as que, com mais
 frequência, utilizam tipagem estática.
 Essas são as declarações que definem a interface de um módulo e, ao tipá-las,
 programadores permitem que o compilador procure por erros de tipos na integraçã
o com outros módulos alem de documentar o contrato deste módulo para que
 clientes saibam como utilizá-lo.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement ht
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset Graphics
	filename ../vem_2013/visibilidade.png
	width 80text%

\end_inset

 
\begin_inset Caption

\begin_layout Plain Layout
Sistemas de Tipo por Visibilidade da Declaração
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:visibilidade"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
No caso de retorno e parâmetros de métodos, o uso de tipos em declarações
 com visibilidade protegida chega a superar o de declarações com visibilidade
 pública.
 Pode-se argumentar que métodos e campos protegidos estabelecem um contrato
 delicado, já que expõem elementos internos de uma superclasse para uma
 subclasse.
 Aparentemente programadores enxergam a necessidade de documentar bem o
 código que define esse tipo de contrato através do uso tipagem estática.
\end_layout

\begin_layout Subsection
Resultados por Tamanho de Projeto
\begin_inset CommandInset label
LatexCommand label
name "sub:Resultados-por-Tamanho"

\end_inset


\end_layout

\begin_layout Standard
A figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:tamanho-geral"

\end_inset

 mostra o uso de tipagem dinâmica em declarações públicas por tamanho de
 projeto.
 Cada barra desse gráfico representa um grupo de projetos agrupado por seu
 tamanho sendo que os limites de cada grupo são definidos sob cada barra.
 Por exemplo, um projeto com 
\begin_inset Formula $1500$
\end_inset

 linhas de código se encontra na segunda barra, pois 
\begin_inset Formula $1500$
\end_inset

 se encontra dentro do intervalo 
\begin_inset Formula $]400,1600]$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement ht
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset Graphics
	filename ../vem_2013/tamanho.png
	width 80text%

\end_inset

 
\begin_inset Caption

\begin_layout Plain Layout
Sistemas de tipo de retornos e parâmetros de métodos públicos agrupados
 por tamanho de projeto.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:tamanho-geral"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este resultado mostra que o uso de tipagem dinâmica em declarações públicas
 diminui à medida que o tamanho do projeto aumenta.
 Projetos com mais de 6400 linhas de código usam tipagem dinâmica com praticamen
te metade de frequência que projetos menores.
 Intuitivamente, quanto maior o projeto, maior a dificuldade de integração
 e a necessidade de manutenção, o que pode levar programadores a preferirem
 o uso de tipagem estática em elementos públicos, os mais críticos para
 esse contexto.
 Nenhum padrão pode ser observado em outros tipos de declaração, reforçando
 a idéia de que esse padrão está relacionado ao papel de elementos públicos
 em projetos grandes.
\end_layout

\begin_layout Subsection
Scripts e Testes
\begin_inset CommandInset label
LatexCommand label
name "sub:Scripts-e-Testes"

\end_inset


\end_layout

\begin_layout Standard
Scripts são, em geral, escritos para desempenhar tarefas simples e não se
 relacionam com muitos outros módulos.
 O mesmo pode ser dito a respeito de código de teste.
 Isso leva a crer que tipagem dinâmica seria utilizada com mais frequência
 nesses contextos uma vez que manutenibilidade e integração não são fatores
 críticos.
 O resultado da tabela 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:teste"

\end_inset

 porem contradiz essa intuição mostrando que não há diferença significativa
 entre o perfil de uso dos sistemas de tipos nesses contextos.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Todos os tipos de declarações agrupadas por classe/script e classes de teste/cla
sses funcionais
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tipagem Estática
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tipagem Dinâmica
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Todas as Classes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
61%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
39%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Scripts
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
54%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
46%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Classes Funcionais
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
62%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
38%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Classes de Teste
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
57%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
43%
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:teste"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Ameaças à validade
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:ameaca"

\end_inset


\end_layout

\begin_layout Standard
Como levantado na seção 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Resultado-Geral"

\end_inset

, programadores tendem a continuar usando o sistema de tipos com o qual
 já estão acostumados.
 Dado que grande parte dos programadores Groovy possuem experiência prévia
 com Java, uma linguagem estaticamente tipada, os resultados mostrados neste
 trabalho podem apresentar certa tendência ao uso de tipagem estática.
 Apesar disso, a análise por tipo de declaração apresentada na seção 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Resultados-por-Tipo"

\end_inset

 mostra a predominância de tipagem dinâmica em variáveis locais, indicando
 que, apesar da experiência anterior com Java, programadores são capazes
 de aprender a usar tipagem dinâmica onde julgam necessário.
\end_layout

\begin_layout Standard
Alguns arcabouços impõem o uso de um dado sistema de tipos em certas situações.
 Spock, por exemplo, um arcabouço de testes automatizados, requer que o
 retorno de métodos que implementam testes seja dinamicamente tipado.
 Porem, graças à heterogeneidade e ao grande número de projetos analisados,
 acredita-se que não haja nenhum arcabouço com utilização tão extensa a
 ponto de influenciar os resultados gerais.
\end_layout

\begin_layout Section
Trabalhos Relacionados
\begin_inset CommandInset label
LatexCommand label
name "sec:Trabalhos-Relacionados"

\end_inset


\end_layout

\begin_layout Standard
Há alguns trabalhos que realizam essa comparação através de estudos controlados.
 Em
\begin_inset CommandInset citation
LatexCommand cite
key "experiment_with_purity"

\end_inset

, o autor compara o desempenho de dois grupos de estudantes quando instruídos
 a desenvolver dois pequenos sistemas.
 Ambos os grupos utilizaram uma linguagem desenvolvida pelo autor, Purity,
 sendo que a única diferença entre eles é que um grupo utiliza uma versão
 desta linguagem com tipagem estática enquanto o outro utilizou uma versão
 com tipagem dinâmica.
 Resultados mostraram que o grupo utilizando a versão dinâmica foi significativa
mente mais produtivo.
 Assim como neste trabalho, o autor foi capaz de comparar dois sistemas
 de tipos diretamente, neste caso desenvolvendo sua própria linguagem.
 Porem, pode-se argumentar que esses resultados podem não representar bem
 situações do cotidiano da indústria de software, uma vez que esse foi um
 estudo de pequena duração onde estudantes são utilizados como exemplos
 de desenvolvedores e que, ainda, não possuem nenhum tipo de interação com
 outros programadores.
 Neste trabalho, tenta-se conseguir resultados mais relevantes ao analisar
 código fonte desenvolvido pro programadores durante suas atividades cotidianas.
\end_layout

\begin_layout Standard
Em uma continuação do estudo acima 
\begin_inset CommandInset citation
LatexCommand cite
key "hanenberg_icpc"

\end_inset

, os autores chegaram a conclusões opostas.
 Eles compararam o desempenho de dois grupos de desenvolvedores em tarefas
 de manutenção, um utilizado Java, uma linguagem estaticamente tipada, e
 o outro, Groovy, usado de forma a simular uma versão de Java dinamicamente
 tipada.
 Nesse caso, o grupo utilizando Java, a linguagem estaticamente tipada,
 foi muito mais produtivo.
 Essa contradição reforça o argumento que os resultados de estudos controlados
 podem não ser confiáveis para analisar essa questão.
\end_layout

\begin_layout Standard
Em experimentos conduzidos em 
\begin_inset CommandInset citation
LatexCommand cite
key "ruby_vs_druby"

\end_inset

, os autores comparam o desempenho de dois grupos trabalhando em pequenas
 tarefas de desenvolvimento.
 Um grupo utilizou Ruby, uma linguagem dinamicamente tipada, enquanto o
 outro usou DRuby, uma versão estaticamente tipada de Ruby.
 Resultados mostraram que o compilador de DRuby raramente conseguiu capturar
 erros que já não eram evidentes para os programadores.
 A maior parte dos envolvidos no estudo tinha experiência prévia com Ruby,
 o que leva a crer que programadores se acostumam com a falta de tipagem
 estática em suas declarações.
\end_layout

\begin_layout Section
Conclusão e Trabalhos Futuros
\begin_inset CommandInset label
LatexCommand label
name "sec:Conclusão-e-Trabalhos"

\end_inset


\end_layout

\begin_layout Standard
Este trabalho estuda quais são os fatores mais importantes para a escolha
 de um sistema de tipos estático ou dinâmico.
 Existem trabalhos na literatura que analisam as vantagens de cada um através
 de estudos controlados.
 Os resultados apresentados aqui, porem, mostram quais são os fatores que
 de fato influenciam essa decisão através da mineração de um amplo conjunto
 de repositórios de software e da visualização do uso destes sistemas de
 tipos.
 
\end_layout

\begin_layout Standard
Quando a necessidade de manutenção e a complexidade de integração entre
 módulos são questões importantes, tipagem estática aparentemente é preferida
 por programadores Groovy.
 Nessas situações a integração com ferramentas de desenvolvimento e a documentaç
ão do código oferecidas pelo sistema de tipos estático são vantagens importantes
 consideradas por programadores.
 Por outro lado, quando essas questões não são tão críticas, a simplicidade
 de tipagem dinâmica parece ser preferida, como visto com declarações de
 variáveis locais.
 Outro fator importante é a experiência prévia de programadores com um dado
 sistema de tipos.
\end_layout

\begin_layout Standard
Em trabalhos futuros deseja-se analisar a influência dos sistemas de tipos
 estático e dinâmico sobre a robustez de sistemas de software.
 Em particular, deseja-se entender se o uso tipagem dinâmica, que limita
 a capacidade do compilador em descobrir problemas de tipo, possui alguma
 correlação com a ocorrência de defeitos no sistema e se o emprego de testes
 automatizados é capaz de diminuir essa correlação.
\end_layout

\begin_layout Section*
Agradecimentos
\end_layout

\begin_layout Standard
Este trabalho recebeu apoio financeiro da FAPEMIG, processos APQ-02376-11
 e APQ-02532-12, e do CNPq processo 485235/2011-0.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "referencias"
options "sbc"

\end_inset


\end_layout

\end_body
\end_document
